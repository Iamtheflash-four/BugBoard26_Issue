package service;

import com.auth0.jwt.exceptions.JWTVerificationException;
import com.auth0.jwt.exceptions.TokenExpiredException;

import dao.IssueAssignmentPostgresDAO;
import dto.AssignIssueDTO;
import jakarta.ws.rs.Consumes;
import jakarta.ws.rs.DELETE;
import jakarta.ws.rs.GET;
import jakarta.ws.rs.HeaderParam;
import jakarta.ws.rs.POST;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.PathParam;
import jakarta.ws.rs.Produces;
import jakarta.ws.rs.core.MediaType;
import jakarta.ws.rs.core.Response;

@Path("/issue")
public class AssegnazioneIssue {
    
    /**
     * Endpoint per assegnare una issue a un utente
     * SOLO GLI ADMIN POSSONO ASSEGNARE LE ISSUE
     */
    @POST
    @Path("/assign")
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    public Response assegnaIssue(
            @HeaderParam("Authorization") String authToken,
            AssignIssueDTO assignDTO) {
        
        try {
            // Validazione input
            if (assignDTO == null || assignDTO.getIdIssue() <= 0 || assignDTO.getIdUtenteAssegnato() <= 0) {
                return Response.status(Response.Status.BAD_REQUEST)
                        .entity("{\"message\": \"Dati non validi. Verificare idIssue e idUtenteAssegnato\"}").build();
            }
            
            // Estrazione e validazione del token
            if (authToken == null || !authToken.startsWith("Bearer ")) {
                return Response.status(Response.Status.UNAUTHORIZED)
                        .entity("{\"message\": \"Token mancante o non valido\"}").build();
            }
            
            String token = authToken.substring(7); // Rimuove "Bearer "
            
            // Validazione token e recupero ID utente
            int idUtente = new TokenGenerator(System.getenv("JWT_SECRET"))
                    .validateUserTokenAndGetID(token);
            
            IssueAssignmentPostgresDAO dao = new IssueAssignmentPostgresDAO();
            
            // VERIFICA CHE L'UTENTE SIA ADMIN
            if (!dao.isAdmin(idUtente)) {
                return Response.status(Response.Status.FORBIDDEN)
                        .entity("{\"message\": \"Accesso negato. Solo gli admin possono assegnare le issue\"}").build();
            }
            
            // Verifica che la issue esista
            if (!dao.issueExists(assignDTO.getIdIssue())) {
                return Response.status(Response.Status.NOT_FOUND)
                        .entity("{\"message\": \"Issue non trovata\"}").build();
            }
            
            // Verifica che l'utente a cui assegnare esista
            if (!dao.userExists(assignDTO.getIdUtenteAssegnato())) {
                return Response.status(Response.Status.BAD_REQUEST)
                        .entity("{\"message\": \"L'utente a cui assegnare la issue non esiste\"}").build();
            }
            
            // Esegui assegnazione
            boolean success = dao.assignIssue(assignDTO.getIdIssue(), assignDTO.getIdUtenteAssegnato());
            
            if (success) {
                return Response.status(Response.Status.OK)
                        .entity("{\"message\": \"Issue assegnata con successo\", " +
                                "\"idIssue\": " + assignDTO.getIdIssue() + ", " +
                                "\"idUtenteAssegnato\": " + assignDTO.getIdUtenteAssegnato() + "}").build();
            } else {
                return Response.status(Response.Status.INTERNAL_SERVER_ERROR)
                        .entity("{\"message\": \"Errore durante l'assegnazione della issue\"}").build();
            }
            
        } catch (TokenExpiredException e) {
            return Response.status(Response.Status.UNAUTHORIZED)
                    .entity("{\"message\": \"Token scaduto\"}").build();
        } catch (JWTVerificationException e) {
            return Response.status(Response.Status.UNAUTHORIZED)
                    .entity("{\"message\": \"Token non valido\"}").build();
        } catch (Exception e) {
            e.printStackTrace();
            return Response.status(Response.Status.INTERNAL_SERVER_ERROR)
                    .entity("{\"message\": \"Errore del server: " + e.getMessage() + "\"}").build();
        }
    }
    
    /**
     * Endpoint per rimuovere l'assegnazione di una issue
     * SOLO GLI ADMIN POSSONO RIMUOVERE L'ASSEGNAZIONE
     */
    @DELETE
    @Path("/{idIssue}/assign")
    @Produces(MediaType.APPLICATION_JSON)
    public Response rimuoviAssegnazione(
            @HeaderParam("Authorization") String authToken,
            @PathParam("idIssue") int idIssue) {
        
        try {
            // Validazione input
            if (idIssue <= 0) {
                return Response.status(Response.Status.BAD_REQUEST)
                        .entity("{\"message\": \"ID issue non valido\"}").build();
            }
            
            // Estrazione e validazione del token
            if (authToken == null || !authToken.startsWith("Bearer ")) {
                return Response.status(Response.Status.UNAUTHORIZED)
                        .entity("{\"message\": \"Token mancante o non valido\"}").build();
            }
            
            String token = authToken.substring(7);
            
            // Validazione token
            int idUtente = new TokenGenerator(System.getenv("JWT_SECRET"))
                    .validateUserTokenAndGetID(token);
            
            IssueAssignmentPostgresDAO dao = new IssueAssignmentPostgresDAO();
            
            // VERIFICA CHE L'UTENTE SIA ADMIN
            if (!dao.isAdmin(idUtente)) {
                return Response.status(Response.Status.FORBIDDEN)
                        .entity("{\"message\": \"Accesso negato. Solo gli admin possono rimuovere l'assegnazione delle issue\"}").build();
            }
            
            // Verifica che la issue esista
            if (!dao.issueExists(idIssue)) {
                return Response.status(Response.Status.NOT_FOUND)
                        .entity("{\"message\": \"Issue non trovata\"}").build();
            }
            
            // Rimuovi assegnazione
            boolean success = dao.unassignIssue(idIssue);
            
            if (success) {
                return Response.status(Response.Status.OK)
                        .entity("{\"message\": \"Assegnazione rimossa con successo\", \"idIssue\": " + idIssue + "}").build();
            } else {
                return Response.status(Response.Status.INTERNAL_SERVER_ERROR)
                        .entity("{\"message\": \"Errore durante la rimozione dell'assegnazione\"}").build();
            }
            
        } catch (TokenExpiredException e) {
            return Response.status(Response.Status.UNAUTHORIZED)
                    .entity("{\"message\": \"Token scaduto\"}").build();
        } catch (JWTVerificationException e) {
            return Response.status(Response.Status.UNAUTHORIZED)
                    .entity("{\"message\": \"Token non valido\"}").build();
        } catch (Exception e) {
            e.printStackTrace();
            return Response.status(Response.Status.INTERNAL_SERVER_ERROR)
                    .entity("{\"message\": \"Errore del server: " + e.getMessage() + "\"}").build();
        }
    }
    
    /**
     * Endpoint per ottenere l'utente assegnato a una issue
     * Accessibile a tutti gli utenti autenticati
     */
    @GET
    @Path("/{idIssue}/assigned-user")
    @Produces(MediaType.APPLICATION_JSON)
    public Response getUtenteAssegnato(
            @HeaderParam("Authorization") String authToken,
            @PathParam("idIssue") int idIssue) {
        
        try {
            // Validazione input
            if (idIssue <= 0) {
                return Response.status(Response.Status.BAD_REQUEST)
                        .entity("{\"message\": \"ID issue non valido\"}").build();
            }
            
            // Estrazione e validazione del token
            if (authToken == null || !authToken.startsWith("Bearer ")) {
                return Response.status(Response.Status.UNAUTHORIZED)
                        .entity("{\"message\": \"Token mancante o non valido\"}").build();
            }
            
            String token = authToken.substring(7);
            
            // Validazione token
            int idUtente = new TokenGenerator(System.getenv("JWT_SECRET"))
                    .validateUserTokenAndGetID(token);
            
            IssueAssignmentPostgresDAO dao = new IssueAssignmentPostgresDAO();
            
            // Verifica che la issue esista
            if (!dao.issueExists(idIssue)) {
                return Response.status(Response.Status.NOT_FOUND)
                        .entity("{\"message\": \"Issue non trovata\"}").build();
            }
            
            // Ottieni utente assegnato
            int assignedUser = dao.getAssignedUser(idIssue);
            
            if (assignedUser > 0) {
                return Response.status(Response.Status.OK)
                        .entity("{\"idIssue\": " + idIssue + ", " +
                                "\"utenteAssegnato\": " + assignedUser + "}").build();
            } else {
                return Response.status(Response.Status.OK)
                        .entity("{\"idIssue\": " + idIssue + ", " +
                                "\"utenteAssegnato\": null, " +
                                "\"message\": \"Nessun utente assegnato\"}").build();
            }
            
        } catch (TokenExpiredException e) {
            return Response.status(Response.Status.UNAUTHORIZED)
                    .entity("{\"message\": \"Token scaduto\"}").build();
        } catch (JWTVerificationException e) {
            return Response.status(Response.Status.UNAUTHORIZED)
                    .entity("{\"message\": \"Token non valido\"}").build();
        } catch (Exception e) {
            e.printStackTrace();
            return Response.status(Response.Status.INTERNAL_SERVER_ERROR)
                    .entity("{\"message\": \"Errore del server: " + e.getMessage() + "\"}").build();
        }
    }
}
